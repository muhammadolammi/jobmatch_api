// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkSubscriptionExist = `-- name: CheckSubscriptionExist :one
SELECT EXISTS(
    SELECT 1 FROM subscriptions WHERE user_id = $1
    )
`

func (q *Queries) CheckSubscriptionExist(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSubscriptionExist, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
 user_id, plan_id )
VALUES ( $1, $2)
RETURNING id, user_id, status, canceled_at, next_payment_date, created_at, updated_at, paystack_sub_code, plan_id
`

type CreateSubscriptionParams struct {
	UserID uuid.UUID
	PlanID uuid.UUID
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription, arg.UserID, arg.PlanID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CanceledAt,
		&i.NextPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaystackSubCode,
		&i.PlanID,
	)
	return i, err
}

const getSubscriptionWithUserID = `-- name: GetSubscriptionWithUserID :one

SELECT id, user_id, status, canceled_at, next_payment_date, created_at, updated_at, paystack_sub_code, plan_id FROM subscriptions 
WHERE user_id=$1
`

func (q *Queries) GetSubscriptionWithUserID(ctx context.Context, userID uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionWithUserID, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CanceledAt,
		&i.NextPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaystackSubCode,
		&i.PlanID,
	)
	return i, err
}

const updateSubscriptionForActivation = `-- name: UpdateSubscriptionForActivation :exec
UPDATE subscriptions
SET 
  next_payment_date = $1,
  status = $2,
  paystack_sub_code = $3

WHERE id = $4
`

type UpdateSubscriptionForActivationParams struct {
	NextPaymentDate sql.NullTime
	Status          string
	PaystackSubCode sql.NullString
	ID              uuid.UUID
}

func (q *Queries) UpdateSubscriptionForActivation(ctx context.Context, arg UpdateSubscriptionForActivationParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionForActivation,
		arg.NextPaymentDate,
		arg.Status,
		arg.PaystackSubCode,
		arg.ID,
	)
	return err
}

const updateSubscriptionNextPaymentDate = `-- name: UpdateSubscriptionNextPaymentDate :exec
UPDATE subscriptions
SET 
  next_payment_date = $1
WHERE id = $2
`

type UpdateSubscriptionNextPaymentDateParams struct {
	NextPaymentDate sql.NullTime
	ID              uuid.UUID
}

func (q *Queries) UpdateSubscriptionNextPaymentDate(ctx context.Context, arg UpdateSubscriptionNextPaymentDateParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionNextPaymentDate, arg.NextPaymentDate, arg.ID)
	return err
}

const updateSubscriptionPlan = `-- name: UpdateSubscriptionPlan :exec
UPDATE subscriptions
SET 
  plan_id = $1
WHERE id = $2
`

type UpdateSubscriptionPlanParams struct {
	PlanID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) UpdateSubscriptionPlan(ctx context.Context, arg UpdateSubscriptionPlanParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionPlan, arg.PlanID, arg.ID)
	return err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :exec
UPDATE subscriptions
SET 
  status = $1
WHERE id = $2
`

type UpdateSubscriptionStatusParams struct {
	Status string
	ID     uuid.UUID
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionStatus, arg.Status, arg.ID)
	return err
}
